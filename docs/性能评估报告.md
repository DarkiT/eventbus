# EventBus 性能评估报告

> **测试环境**: AMD EPYC 9K65 192-Core Processor, Linux amd64  
> **Go 版本**: Go 1.23+  
> **更新时间**: 2025-10-16

## 📊 执行摘要

### 核心性能指标

✅ **优秀性能**
- **Pipe 同步发布**: 47.98 ns/op（8B 内存，1 次分配）
- **CowMap 读操作**: 13.30 ns/op（零内存分配）
- **EventBus 同步发布**: 595.0 ns/op（111B 内存，3 次分配）
- **EventBus 异步发布**: 1,406 ns/op（128B 内存，2 次分配）

⚠️ **性能瓶颈**
- **CowMap 写入**: 适用于读多写少场景，写密集场景建议使用 sync.Map
- **内存分配**: 响应式发布场景存在优化空间

---

## 📈 详细基准测试数据

### 1. EventBus 核心性能

| 操作类型 | 延迟 (ns/op) | 内存 (B/op) | 分配次数 |
|---------|-------------|------------|---------|
| 同步发布 | 595.0 | 111 | 3 |
| 异步发布 | 1,406 | 128 | 2 |
| 高并发发布 | 5,485 | 480 | 12 |

**性能特点**：
- 同步发布性能优秀，适合实时性要求高的场景
- 异步发布内存开销小，适合高吞吐量场景
- 并发性能稳定，支持大规模并发订阅

### 2. Pipe 泛型管道性能

| 操作类型 | 延迟 (ns/op) | 内存 (B/op) | 分配次数 |
|---------|-------------|------------|---------|
| 同步发布 | 47.98 | 8 | 1 |
| 异步发布 | ~100 | 16 | 2 |

**性能特点**：
- 极低延迟，适合对性能要求极高的场景
- 类型安全，编译时检查
- 内存开销最小

### 3. CowMap 性能分析

#### 读操作性能（优势场景）

| 操作类型 | CowMap | sync.Map | 性能比 |
|---------|--------|----------|--------|
| 单线程读取 | 13.30 ns/op | 16.13 ns/op | **快 1.2x** |
| 多线程读取（不同键） | 5,097 ns/op | 6,590 ns/op | **快 1.3x** |
| 多线程读取（相同键） | 742 ns/op | 759 ns/op | **快 1.0x** |

#### 写操作性能（限制场景）

| 操作类型 | CowMap | sync.Map | 性能比 |
|---------|--------|----------|--------|
| 写入不存在键 | 563,206 ns/op | 1,204 ns/op | **慢 466x** |
| 更新已存在键 | 42.44 ns/op | 59.08 ns/op | **快 1.4x** |

**重要说明**：
- CowMap 专为"读多写少"场景优化
- 写操作触发完整复制，时间复杂度 O(n)
- 建议在订阅表管理等读密集场景使用
- 写密集场景建议使用 sync.Map

---

## 🎯 性能优化建议

### 1. 场景选择

**推荐使用场景**：
- ✅ 订阅管理（读多写少）
- ✅ 实时事件分发
- ✅ 高并发读取
- ✅ 低延迟要求

**谨慎使用场景**：
- ⚠️ 频繁订阅/取消订阅
- ⚠️ 大量动态主题
- ⚠️ 写密集型场景

### 2. 配置优化

```go
// 高吞吐量场景
bus := eventbus.NewBuffered(10000)

// 低延迟场景
bus := eventbus.New() // 无缓冲

// 类型安全场景
pipe := eventbus.NewPipe[MyData](100)
```

### 3. 内存优化

- 使用对象池减少分配
- 避免过大的事件负载
- 合理设置缓冲区大小
- 及时取消不需要的订阅

---

## 📌 最佳实践

### 性能监控

```go
// 定期检查健康状态
status := bus.HealthCheck()
if !status.Healthy {
    log.Warn("事件总线异常", status.Message)
}

// 获取统计信息
stats := bus.GetStats()
log.Info("事件总线统计",
    "订阅数", stats.SubscriberCount,
    "主题数", stats.TopicCount,
    "队列深度", stats.QueueDepth)
```

### 性能测试

```go
func BenchmarkYourScenario(b *testing.B) {
    bus := eventbus.NewBuffered(1024)
    bus.Subscribe("test", func(topic string, payload any) {
        // 处理逻辑
    })
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        bus.Publish("test", "payload")
    }
}
```

---

## 📝 总结

EventBus 在设计目标场景（事件驱动、读多写少）下表现优秀：

✅ **核心优势**
- 极低的发布延迟（纳秒级）
- 出色的并发读取性能
- 类型安全的泛型管道
- 完善的监控和追踪

⚠️ **使用建议**
- 根据场景选择合适的组件（EventBus/Pipe/CowMap）
- 写密集场景考虑其他方案
- 定期监控性能指标
- 合理配置缓冲区大小

---

**版本信息**: v0.2.0  
**测试日期**: 2025-10-16  
**基准测试命令**: `go test -bench=. -benchmem ./...`
